# 目的

Reactor 设计模式处理由一个或者多个客户端同时提交给应用程序的服务请求（service requests）。在应用程序中，每个服务可能由几个方法构成，并由负责分派服务特定的请求（Service-specific requests）的一个独立的事件处理器表示。事件处理器的分派由初始分发器（initiation dispatcher）执行，该分发器管理已注册的事件处理程序。服务请求的多路分解由一个同步事件多路分解器完成。



# 别称

分发器（Dispatcher）, 通知器（Notifier）



# 例子

为了阐述 Reactor 模式，请看图1所示的运行着分布式日志记录服务的事件驱动服务器。

![Logging server](/Users/chisoncloud/projects/reactor-translation/logging-server.png)



客户端在分布式环境中使用日志服务来记录他们的状态信息，这些信息通常包括错误通知、调试跟踪信息和性能报告等。日志记录被发往这个中央日志服务器，服务器可以把他们写入各种输出设备，比如终端、打印机、文件或者网络数据库。

图 1 所示的这个日志服务器处理客户端发送来的日志记录，日志记录数据和连接请求可以同时出现在不同的句柄（Handle）上，句柄代表着由操作系统管理的网络通信资源【注：也就是图中的 `SOCKET HANDLES`】。

日志服务器跟客户端使用面向连接的洗衣通信，比如 `TCP` 协议，客户端如果想要记录数据必须先发送连接请求到服务器，服务器使用监听这些客户端已知地址的 *句柄工厂（handle factory）* 等待这些连接请求的到来。当连接请求到达时，句柄工厂通过创建一个表示连接端点的新句柄，在客户端和服务器之间建立连接，这个句柄会返回给服务器，然后服务器等待客户端的服务请求到达这个句柄。一旦客户端跟服务器建立了连接，客户端就可以并发的发送日志记录到服务器，服务器可以通过这些已经建立连接的 `Socket` 句柄来接收这些记录。

也许开发一个支持并发的日志服务器最符合直觉的方式就是像图 2 中展示的那样使用多个线程来同时处理多个客户端。



![](/Users/chisoncloud/projects/reactor-translation/multi-thread-logging-server.png)

这种方法同步地接受网络连接，并按照“一个线程一个连接（thread-per-connection）”的模式来处理客户端日志记录。然而，使用多线程在服务器中实现日志记录的处理无法解决以下问题：

